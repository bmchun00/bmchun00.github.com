---
title: "Stack - based simple PASCAL program"
tags:
- "컴파일러"
---

```
program example;
var abc, e3, fg:real;
begin
    abc := e3 * 2.56 + abc / e3;
end
```
이러한 코드가 있다. 그러면 만들어지는 syntax tree는 다음과 같을 것이다.

![]({{ 'assets/compiler/5.jpeg' | relative_url }})

또한 symbol table은 다음과 같다. real type의 크기가 4byte라고 가정했을 때이다.

**Symbol table for variables**

|name|type|addr|
|----|----|----|
|abc|real|100|
|e3|real|104|
|fg|real|108|

**Symbol table for constants**

|name|type|addr|
|----|----|----|
|2.56|real|200|

이 둘을 한번에 만들수도 있고, 따로 만들수도 있다. 그리고 constants 테이블의 경우 2.56인 string이 아니라 real로 변환된 값이 저장되어 있어야 한다.

**Intermediate representation (Syntax tree를 post-order 순회하며)**

|op|arg1|arg2|result|
|----|----|----|---|
|*|e3|2.56|t0|
|/|abc|e3|t1|
|+|t0|t1|t2|
|:=|t2| |abc|

**Postfix expression for the assignment**

abc e3 2.56 * abc e3 / + :=

**VM Codes**

```
LoadAddr  100   ;abc의 주소
LoadValue 104   ;e3의 값
LoadValue 200   ;2.56
Operation 5     ;*
LoadValue 100   ;abc의 값
LoadValue 104   ;e3의 값
Operation 6     ;/
Operation 3     ;+
Operation 1     ;:=
```

**Interpreter execution**

after 1 : 100<br>
after 2 : 100 e3<br>
after 3 : 100 e3 2.56<br>
after 4 : 100 (e3*2.56)<br>
after 5 : 100 (e3*2.56) abc<br>
after 6 : 100 (e3*2.56) abc e3<br>
after 7 : 100 (e3*2.56) (abc/e3)<br>
after 8 : 100 {(e3*2.56)+(abc/e3)}<br>
after 9 : {(e3*2.56)+(abc/e3)} 와 100을 pop하고 100의 위치에 {(e3*2.56)+(abc/e3)}를 저장. 즉, abc의 값으로 대입
