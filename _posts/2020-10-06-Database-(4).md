---
title: Database (4)
tag: 데이터베이스
---

```
-- 데이터 정의어
-- create, alter, drop

-- 데이터 조작어
-- select

select 'hello world';
select 3+5;
select deptno, deptname from department;

select title from employee;
--- 관계대수 연산자 projection의 결과에는 중복값이 포함되지 않습니다.
--- sql의 select에서는 중복값을 포함합니다.
--- 중복값을 제거하려면, distinct를 활용합니다.

select distinct title from employee;
-- distinct는 모든 컬럼 값을 따졌을 때 중복을 제거합니다.

-- where : 조건 검색
-- 특정 조건을 만족하는 투플들을 검색할 때 활용합니다.(필터링, 실렉션)
-- =, >, >= 등의 비교연산자 적용
-- like : 문자열의 포함관계 검색
-- in, not in : 집합의 포함관계
-- between a and b : a와 b 사이에 해당하는 값

-- like 예제 : 사원 이름이 '이'로 시작하는 사원들의 모든 정보 검색
-- % : 문자열
select * from employee where empname like '이%';
-- 사원 이름이 권으로 끝나는 사원
select * from employee where empname like '%권';
-- 사원 이름에 수가 들어가는 사원
select * from employee where empname like '%수%';

-- 컬럼의 타입 바꾸기
-- 1. 테이블 수정
-- 2. 컬럼 수정
-- 3. 타입 수정
alter table employee alter column empname type varchar(10);
-- varchar(x) 최대 x의 길이를 갖는 유동 크기 문자열
-- char(x) x의 고정 길이를 갖는 문자열

-- 고정 길이 : _언더스코어 활용
-- 성이 '이'로 시작하는 세 글자 이름 사원 검색
select * from employee where empname like '이__';

-- 성이 '김' , 끝이 '수'로 끝나는 세 글자 이름 사원 검색
update employee set empname = '김준수' where empname = '최종철';

select * from employee where empname like '김_수';


--- 만약에 고정 길이 문자열로 컬럼이 되어있고, 컬럼의 타입을 수정하지 않은 상태에서
--- 공백을 제거하고 특정 문자의 포함여부를 검색하는 방법
-- trim 메소드를 이용 : 문자열의 공백을 제거 '--___' -> '--'
-- '사원______' -> trim('사원______') => '사원'
-- 직접적으로 데이터를 변경하는 것은 아님

-- '원'으로 끝나는 직급에 해당하는 사원들의 모든 정보를 검색하시오.
select * from employee where trim(title) like '%원';

-- 사원 중 1번 부서가 아닌 사원들의 모든 정보 (조건에 맞는데도 널값이 나오지 않는것을 볼수있음)
select * from employee where dno != 1;
select * from employee where dno <> 1;

-- 김정현 사원 추가 (dno는 외래키이므로 가능)
insert into employee values(5000, '김정현', '사원',2106,1500000,NULL);

-- 널값을 포함해야함
select * from employee where dno != 1 or dno is null;

-- 1, 2번 부서 중 어디든 속한 사람의 모든 정보
select * from employee where dno in (1,2);

-- 산술 연산. 사원들의 이름과 월급, 월급의 10%인상액을 계산해 검색
select empname, salary, salary*1.1 as new_sel from employee
-- select 구문은 산술 연산이 가능합니다. as키워드를 통해 별칭을 붙일 수 있습니다.
select empname, salary, salary*1.1 as new_sel, new_sel-salary from employee
-- 이때 new_sel-salary와 같은 연산은 불가능합니다. new_sel이 원래부터 있는 칼럼이 아니기 때문입니다.

-- 월급순으로 사원정보를 정렬
select *
from employee
order by salary asc -- 원래는 asc가 없어도 됩니다.
-- order by는 정렬. 기본은 오름차순
select *
from employee
order by salary desc
-- 내림차순은 이런 방법으로

-- limit, offset
-- limit : 상위 n개만
-- offset : 상위 n개 제외

-- 월급이 높은 상위 3가지
select *
from employee
order by salary desc
limit 3;

-- 월급이 높은 상위 3가지 를 제외한 나머지
select *
from employee
order by salary desc
offset 3;
```
