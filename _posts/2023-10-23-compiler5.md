---
title: "DFA NFA 변환, regular 연산의 Formal 표현"
tags:
- "컴파일러"
use_math: true
---

# Every NFA has equivalent DFA
'모든 NFA는 equivalent DFA가 존재한다'의 formal한 증명<br>
$Proof, \,Let\,N=(Q,\sum,\sigma,q_0,F)\,be\,the\,NFA\,recognizing\,some\,language\,A$<br>
이때 A를 인식하는 새로운 DFA $M=(Q',\sum,\sigma',q_0',F')$ 를 정의한다.

1. $Q'$ = $P(Q)$, power set of $Q$
2. $\sum$ = $N$의 $\sum$과 같음
3. $\sigma(R,a)'=\{q\in Q \mid q \in E(\sigma(r,a))\,for\,some\,r\in R\}\, for\,R\in Q'\,and\,a\in\sum$
4. $q_0'=E(\{q_0\})$ 
5. $F = \{R \in Q'\mid R\,contains\,an\,accepting\,state\,of\,N\}$

이때 $E(R)$이란, $M$의 어떤 state $R$에 대해서도 $\epsilon$화살표만 따라가서 R의 memeber로 도달할 수 있는 state의 집합이다.

만약 $w=0110$인 $w$를 $w=01\epsilon 1\epsilon 0\epsilon$처럼 쓸 수 있다.

---
# 레귤러 연산의 Formal한 표현
$L_1\cup L_2,\,L_1\circ L_2,\,L_1^*$<br>
각각의 $L_1,\,L_2$가 regular이면 연산 후에도 regular이다. 즉, 그것을 Accept하는 NFA/DFA가 존재한다.
그림으로는 다음과 같이 그릴 수 있다.<br>
![]({{ 'assets/compiler/16.jpeg' | relative_url }})<br>
즉 $L_1\cup L_2$또한 regular하다.
